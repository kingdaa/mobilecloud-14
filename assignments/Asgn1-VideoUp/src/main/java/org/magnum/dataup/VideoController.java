package org.magnum.dataup;

import java.io.IOException;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.magnum.dataup.model.Video;
import org.magnum.dataup.model.VideoStatus;
import org.magnum.dataup.model.VideoStatus.VideoState;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.multipart.MultipartFile;

@Controller
public class VideoController {
	// An in-memory list that the servlet uses to store the
	// videos that are sent to it by clients
	// private List<Video> videos = new CopyOnWriteArrayList<Video>();
	private static final AtomicLong currentId = new AtomicLong(0L);
	private Map<Long, Video> videos = new ConcurrentHashMap<Long, Video>();
	private VideoFileManager videoDataMgr;

	@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "No such Video")
	// 404
	class DataNotFoundException extends RuntimeException {
		private static final long serialVersionUID = 4812124269831129480L;
	}

	/*
	 * POST /video
	 * 
	 * The video metadata is provided as an application/json request body. The
	 * JSON should generate a valid instance of the Video class when
	 * deserialized by Spring's default Jackson library.
	 * 
	 * Returns the JSON representation of the Video object that was stored along
	 * with any updates to that object made by the server.
	 * 
	 * The server should generate a unique identifier for the Video object and
	 * assign it to the Video by calling its setId(...) method.
	 * 
	 * No video should have ID = 0. All IDs should be > 0.
	 * 
	 * The returned Video JSON should include this server-generated identifier
	 * so that the client can refer to it when uploading the binary mpeg video
	 * content for the Video.
	 * 
	 * The server should also generate a "data url" for the Video. The
	 * "data url" is the url of the binary data for a Video (e.g., the raw mpeg
	 * data). The URL should be the full URL for the video and not just the path
	 * (e.g., http://localhost:8080/video/1/data would be a valid data url). See
	 * the Hints section for some ideas on how to generate this URL.
	 */
	@RequestMapping(value = VideoSvcApi.VIDEO_SVC_PATH, method = RequestMethod.POST)
	public @ResponseBody
	Video addVideo(@RequestBody Video v) {
		// TODO - store the video
		checkAndSetId(v);
		v.setDataUrl(getDataUrl(v.getId()));
		videos.put(v.getId(), v);
		return v;
	}

	/*
	 * GET /video
	 * 
	 * Returns the list of videos that have been added to the server as JSON.
	 * The list of videos does not have to be persisted across restarts of the
	 * server. The list of Video objects should be able to be unmarshalled by
	 * the client into a Collection.
	 * 
	 * The return content-type should be application/json, which will be the
	 * default if you use @ResponseBody
	 */
	@RequestMapping(value = VideoSvcApi.VIDEO_SVC_PATH, method = RequestMethod.GET)
	public @ResponseBody
	Collection<Video> getVideoList() {
		return videos.values();
	}

	/*
	 * POST /video/{id}/data
	 * 
	 * The binary mpeg data for the video should be provided in a multipart
	 * request as a part with the key "data". The id in the path should be
	 * replaced with the unique identifier generated by the server for the
	 * Video. A client MUST create a Video first by sending a POST to /video and
	 * getting the identifier for the newly created Video object before sending
	 * a POST to /video/{id}/data.
	 * 
	 * The endpoint should return a VideoStatus object with
	 * state=VideoState.READY if the request succeeds and the appropriate HTTP
	 * error status otherwise. VideoState.PROCESSING is not used in this
	 * assignment but is present in VideoState.
	 */

	@RequestMapping(value = VideoSvcApi.VIDEO_DATA_PATH, method = RequestMethod.POST)
	public @ResponseBody
	ResponseEntity<VideoStatus> setVideoData(
			@PathVariable(VideoSvcApi.ID_PARAMETER) long id,
			@RequestParam(VideoSvcApi.DATA_PARAMETER) MultipartFile videoData) {
		// TODO
		try {
			if (videoDataMgr == null)
				videoDataMgr = VideoFileManager.get();
			saveSomeVideo(videos.get(id), videoData);
			return new ResponseEntity<VideoStatus>(new VideoStatus(
					VideoState.READY), HttpStatus.OK);
		} catch (Exception e) {
			return new ResponseEntity<VideoStatus>(HttpStatus.NOT_FOUND);
		}
	}

	/*
	 * GET /video/{id}/data
	 * 
	 * Returns the binary mpeg data (if any) for the video with the given
	 * identifier. If no mpeg data has been uploaded for the specified video,
	 * then the server should return a 404 status code.
	 */
	@RequestMapping(value = VideoSvcApi.VIDEO_DATA_PATH, method = RequestMethod.GET)
	public void getData(@PathVariable(VideoSvcApi.ID_PARAMETER) long id,
			HttpServletResponse response) {
		try {
			if (videoDataMgr == null)
				videoDataMgr = VideoFileManager.get();
			videoDataMgr.copyVideoData(videos.get(id), response.getOutputStream());
		} catch (Exception e) {
			throw new DataNotFoundException();
		}
		// Video video = videos.get(id);
		// if (video == null)
		// throw new DataNotFoundException();
		// if (!videoDataMgr.hasVideoData(video))
		// throw new DataNotFoundException();
		// ByteArrayOutputStream out = new ByteArrayOutputStream();
		// try {
		// videoDataMgr = VideoFileManager.get();
		// videoDataMgr.copyVideoData(video, out);
		// } catch (IOException e) {
		// e.printStackTrace();
		// throw new DataNotFoundException();
		// }
		// return new Response(video.getDataUrl(), 200, "Success", null,
		// new TypedByteArray("video/mpeg", out.toByteArray()));
	}

	// You would need some Controller method to call this...
	public void saveSomeVideo(Video v, MultipartFile videoData)
			throws IOException {
		videoDataMgr.saveVideoData(v, videoData.getInputStream());
	}

	public void serveSomeVideo(Video v, HttpServletResponse response)
			throws IOException {
		// Of course, you would need to send some headers, etc. to the
		// client too!
		// ...
		videoDataMgr.copyVideoData(v, response.getOutputStream());
	}

	private void checkAndSetId(Video v) {
		if (v.getId() == 0) {
			v.setId(currentId.incrementAndGet());
		}
	}

	private String getDataUrl(long videoId) {
		String url = getUrlBaseForLocalServer() + "/video/" + videoId + "/data";
		return url;
	}

	private String getUrlBaseForLocalServer() {
		HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder
				.getRequestAttributes()).getRequest();
		String base = "http://"
				+ request.getServerName()
				+ ((request.getServerPort() != 80) ? ":"
						+ request.getServerPort() : "");
		return base;
	}
}
